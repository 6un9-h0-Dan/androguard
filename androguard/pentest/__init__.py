from . import adb

import frida
import json
import threading

from loguru import logger

class Pentest:
    def __init__(self):
        self.package_name = None
        self.device = None
        self.frida_session = None
        self.pid = -1
        self.detached = False
        self.scripts = []
        self.pending = []
        self.list_file_scripts = []
        self.ag_scripts = ['androguard/pentest/modules/utils.js']

    def disconnect(self):   
        self.package_name = None
        self.device = None
        self.frida_session = None
        self.pid = -1
        self.scripts = []
        self.pending = []
        self.list_file_scripts = []


    def print_devices(self):
        logger.info("List of devices")
        devices = frida.enumerate_devices()
        for i in range(len(devices)):
            logger.info('{}) {}'.format(i, devices[i]))

    def connect_default_usb(self):
        self.device = frida.get_usb_device()
        logger.info("Connected to device {}".format(self.device))

    def _read_scripts(self, scripts):
        data_scripts = ""

        for script_file in scripts:
            with open(script_file, 'r') as file:
                data_scripts += file.read()
                data_scripts += '\n\n'
        
        return data_scripts

    def read_scripts(self, scripts):
        return self._read_scripts(self.ag_scripts + scripts)

    def install_apk(self, filename):
        adb.adb(self.device.id, "install {}".format(filename))

    def spawn_package(self, package_name, list_file_scripts):
        self.package_name = package_name

        logger.info("Starting package {} {}".format(package_name, list_file_scripts))


        self.list_file_scripts = list_file_scripts

        self.device.on('spawn-added', self.spawn_added)
        self.device.on('spawn-removed', self.spawn_removed)
        self.device.on('child-added', self.child_added)
        self.device.on('child-removed', self.on_spawned)
        self.device.on('process-crashed', self.on_spawned)
        self.device.on('output', self.on_spawned)
        self.device.on('uninjected', self.on_spawned)
        self.device.on('lost', self.on_spawned)
        self.device.enable_spawn_gating()
        self.event = threading.Event()
        logger.info('Enabled spawn gating')

        try:
            self.pid = self.device.spawn([package_name])
            self.frida_session = self.device.attach(self.pid)
            self.frida_session.on('detached', self.on_detached)
            self.load_scripts(self.frida_session, list_file_scripts)
        except frida.NotSupportedError as e:
            logger.error(e)

        

    def load_scripts(self, current_session, scripts):
        script = current_session.create_script(self.read_scripts(scripts))

        script.on("message", self.my_message_handler)
        script.load()  
        self.scripts.append(script)

    def run_frida(self):
        self.device.resume(self.pid)

        logger.warning("Type 'e' to exit the strace ")
        s = ""
        while (s!='e') and (not self.detached):
            s = input("Type 'e' to exit:")          
            
        if self.scripts:
            for script in self.scripts:
                script.unload()

    def start_strace(self, filename, session):
        apk_obj, dex_objs, dx_obj = session.get_objects_apk(filename)
        if not apk_obj:
            logger.error("Can't find any APK object associated")
            return
        
        if not self.device:
            logger.error("Not connected to any device yet")
            return

        self.install_apk(filename)
        self.spawn_package(apk_obj.get_package(), 
        [
            'androguard/pentest/modules/ipc/intents.js', 
            'androguard/pentest/modules/webviews/webviews.js'
        ])
        
        self.run_frida()
       
    def my_message_handler(self, message, payload):
        logger.debug("MESSAGE {} {}".format(message, payload))

        if message["type"] == "send":
            msg_payload = json.loads(message["payload"])
            params = {}
            for i in msg_payload:
                if i not in ["id", "ret", "timestamp", "stacktrace"]:
                    params[i] = msg_payload[i]

            logger.info("[{}][{}:{}] [{}] -> [{}]".format(msg_payload["timestamp"], msg_payload["stacktrace"][0], msg_payload["stacktrace"][1], params, msg_payload.get("ret")))

    def on_detached(self, reason):
        logger.info("Session is detached due to: {}".format(reason))
        self.detached = True
    
    def on_spawned(self, spawn):
        logger.info('on_spawned: {}'.format(spawn))
        self.pending.append(spawn)
        self.event.set()
    
    def spawn_added(self, spawn):
        logger.info('spawn_added: {}'.format(spawn))
        
        self.event.set()

        if(spawn.identifier.startswith(self.package_name)):
            logger.info('added tace: {}'.format(spawn))
        
            session = self.device.attach(spawn.pid) 
            self.load_scripts(session, self.list_file_scripts)
            self.device.resume(spawn.pid)
            logger.info('Resumed')
            
    def spawn_removed(self, spawn):
        logger.info('spawn_removed: {}'.format(spawn))
        self.event.set()

    def child_added(self, spawn):
        logger.info('child_added: {}'.format(spawn))